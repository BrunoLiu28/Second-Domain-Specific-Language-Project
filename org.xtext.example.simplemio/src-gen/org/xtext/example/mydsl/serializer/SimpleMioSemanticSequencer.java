/*
 * generated by Xtext 2.34.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.SimpleMioGrammarAccess;
import simplemioModel.And;
import simplemioModel.Event;
import simplemioModel.Model;
import simplemioModel.Not;
import simplemioModel.Or;
import simplemioModel.Program;
import simplemioModel.Sensor;
import simplemioModel.SimplemioModelPackage;

@SuppressWarnings("all")
public class SimpleMioSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SimpleMioGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SimplemioModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SimplemioModelPackage.ACTION:
				sequence_Action(context, (simplemioModel.Action) semanticObject); 
				return; 
			case SimplemioModelPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case SimplemioModelPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case SimplemioModelPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SimplemioModelPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case SimplemioModelPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case SimplemioModelPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case SimplemioModelPackage.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (
	 *         (actionName='move' | actionName='led' | actionName='turn' | actionName='stop') 
	 *         (
	 *             actionSpecifier='left' | 
	 *             actionSpecifier='right' | 
	 *             actionSpecifier='forward' | 
	 *             actionSpecifier='backward' | 
	 *             actionSpecifier='red' | 
	 *             actionSpecifier='green' | 
	 *             actionSpecifier='blue' | 
	 *             actionSpecifier='off'
	 *         )? 
	 *         strength=EInt?
	 *     )
	 * </pre>
	 */
	protected void sequence_Action(ISerializationContext context, simplemioModel.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Not returns And
	 *     Paren returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Not)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplemioModelPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplemioModelPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, SimplemioModelPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplemioModelPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightNotParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (conditionalsensor=Or actions+=Action actions+=Action*)
	 * </pre>
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     program=Program
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplemioModelPackage.Literals.MODEL__PROGRAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplemioModelPackage.Literals.MODEL__PROGRAM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getProgramProgramParserRuleCall_1_0(), semanticObject.getProgram());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Not returns Not
	 *     Paren returns Not
	 *
	 * Constraint:
	 *     (conditionalsensor=Paren | conditionalsensor=Sensor)
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Not returns Or
	 *     Paren returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SimplemioModelPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplemioModelPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SimplemioModelPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimplemioModelPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     events+=Event+
	 * </pre>
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Or returns Sensor
	 *     Or.Or_1_0 returns Sensor
	 *     And returns Sensor
	 *     And.And_1_0 returns Sensor
	 *     Not returns Sensor
	 *     Paren returns Sensor
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (
	 *         (sensorName='obstacle' | sensorName='sound' | sensorName='line' | sensorName='button' | sensorName='motor') 
	 *         (
	 *             sensorSpecifier='front' | 
	 *             sensorSpecifier='back' | 
	 *             sensorSpecifier='left' | 
	 *             sensorSpecifier='right' | 
	 *             sensorSpecifier='up' | 
	 *             sensorSpecifier='down' | 
	 *             sensorSpecifier='center'
	 *         )? 
	 *         strength=EInt?
	 *     )
	 * </pre>
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
